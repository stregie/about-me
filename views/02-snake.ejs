<html>
    <style>
      h2{
        text-align: center;
      }
      #snake-canvas{
        background:  var(--color-bg-1);
        border: 3px solid var(--color-border-1);
        border-radius: 10px;
        display: block;
        margin: auto;   
      }
      #start-button{
        display: block;
        margin: auto;
        width:  806px;
      }
      
    </style>
    <div class = "container">
      <h2>Snake</h2>
      <p>A classic snake game. Use the <strong>W, S, A, D</strong> keys to control the snake. For test purposes you can also press <strong>G</strong> to make the snake grow or press <strong>F</strong> to reposition the apple to a new random place. <strong>Escape</strong> quits the game. The site is not responsive, feel free to use the zoom funcion of the browser if it is too big or too small.</p>
      <p>Score: <span id = "score">0</span></p>

      <canvas id = "snake-canvas" width = "800" height = "440"></canvas><br> <!-- Canvas width and height should be dividable by 20 -->
      <button class = "btn btn-basic" id = "start-button">Start</button>
      <br>
      <br>
    </div>

    <script>
      $(document).ready(function(){
        $('#start-button').click(snakeGame);
      });
      function snakeGame(){

        let score = 0;
        document.getElementById('score').textContent = score;

        const canvasHtml = document.getElementById("snake-canvas");
        const ctx = canvasHtml.getContext("2d");
        
        // The new Object() method is used instead an object literal to avoid accessing properties before declaration
        const canvas = new Object();
        canvas.squareSize = 20; // side of a square
        canvas.rightedge = canvasHtml.getAttributeNode("width").value / canvas.squareSize;
        canvas.bottom = canvasHtml.getAttributeNode("height").value / canvas.squareSize;
        canvas.clear = () => { 
          ctx.clearRect(0, 0, canvas.rightedge * canvas.squareSize, canvas.bottom * canvas.squareSize);
        };
        canvas.drawSquare = ([ x, y ], color) => {
          ctx.fillStyle = color;
          ctx.fillRect(x * canvas.squareSize, y * canvas.squareSize, canvas.squareSize, canvas.squareSize);
        };

        const isHit = ([ x, y ], [ x2, y2 ]) => x === x2 && y === y2;

        const snake = new Object();
        snake.direction = [1, 0];
        snake.body = [[5, 5], [4, 5], [3, 5], [2, 5]];
        snake.color = getComputedStyle(document.documentElement).getPropertyValue('--color-item-3');
        snake.draw = () => {
          snake.body.forEach((coord) => canvas.drawSquare(coord, snake.color));
        };
        snake.growth = 3;
        snake.getNextStep = () => {
          return [snake.body[0][0] + snake.direction[0], snake.body[0][1] + snake.direction[1]];
        };
        snake.check180turn = () => {
          if(isHit(snake.nextStep, snake.body[1])){
            snake.direction[0] = snake.direction[0] * -1;
            snake.direction[1] = snake.direction[1] * -1;
            snake.nextStep = snake.getNextStep();
          }
        };
        snake.checkApple = () => {        
          if(isHit(snake.nextStep, apple.position)){
            snake.growth = snake.growth + 3;
            apple.newApple();
            score++;
            document.getElementById('score').textContent = score;
          }
        };
        snake.checkHitSelf = () => {
          if(snake.body.some((position) => isHit(position, snake.nextStep))){
            gameOver("Hit self");
          }
        };
        snake.checkHitWall = () => {
          if(snake.nextStep[0] === -1 || snake.nextStep[0] === canvas.rightedge || snake.nextStep[1] === -1 || snake.nextStep[1] === canvas.bottom) gameOver('Wall hit');
        };
        snake.updatePosition = () => {
          // snake.body.unshift([snake.body[0][0] + snake.direction[0], snake.body[0][1] + snake.direction[1]]);
          snake.body.unshift(snake.getNextStep());
          if(snake.growth > 0){
            snake.growth--;
          } else {
            snake.body.pop();
          }
        };

        const apple = new Object();
        apple.position = [7, 8];
        apple.color = "#AD343E";
        apple.draw = () => {
          canvas.drawSquare(apple.position, apple.color);
        };
        apple.newApple = () => {
          let regen = true;
          while (regen) {
            regen = false; 
            apple.position = [ Math.floor(Math.random() * canvas.rightedge), Math.floor(Math.random() * canvas.bottom) ]
            if(snake.body.some((position) => isHit(position, apple.position))){ // check if apple is spawned on snake body
              regen = true;
            } 
          }
        };

        const handleKeyPress = (k) => {
          snake.currentDirection = [...snake.direction]; // Stores the last direction before the keystrok

          if (k.code === 'KeyW'){ // move up
            snake.direction = [0, -1];
          }
          if (k.code === 'KeyS'){ // move down
            snake.direction = [0, 1];
          }
          if (k.code === 'KeyA'){ // move left
            snake.direction = [-1, 0];
          }
          if (k.code === 'KeyD'){ // move right
            snake.direction = [1, 0];
          }
          if (k.code === 'KeyG'){ // grow snake - for test purposes
            // growth = 3;
          }
          if (k.code === 'KeyF'){ // place new apple - for test purposes
            apple.newApple();
          }
          if (k.code === 'Escape'){ // place new apple - for test purposes
            gameOver("Manual abort");
          }

          // If snake turns, turn immediately, to assist zig-zag movements
          // If a pressed key does not change direction, it won't step forward immediately to prevent jumping forward.
          if (snake.currentDirection[0] !== snake.direction[0] && snake.currentDirection[1] !== snake.direction[1]){
            tick = cycle;
          } 
        };
        document.addEventListener('keydown', handleKeyPress);


        const cycle = 5; // length of one cycle - can be used adjust speed of game. Min 2
        let tick = 0;

        const gameLoop = () => {
          if (tick < cycle){
            tick++;
          } else { 
            // new cycle starts if direction is changed or we reach max ticks
            snake.nextStep = snake.getNextStep();
            snake.check180turn();
            snake.checkHitSelf();
            snake.checkHitWall();
            snake.checkApple();
            snake.updatePosition();
            canvas.clear();
            snake.draw();
            apple.draw();
            tick = 0; // New cycle
          }
        };

        const game = setInterval(gameLoop, 10);

        const gameOver = (reason) => {
          console.log(reason);
          alert("Game Over! Your final score is: " + score);
          clearInterval(game);     
          document.removeEventListener('keydown', handleKeyPress);
        };        
      };
    </script>
</html>